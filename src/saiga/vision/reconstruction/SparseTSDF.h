/**
 * Copyright (c) 2017 Darius Rückert
 * Licensed under the MIT License.
 * See LICENSE file for more information.
 */

#pragma once
#include "saiga/core/geometry/all.h"
#include "saiga/core/image/all.h"
#include "saiga/core/util/ProgressBar.h"
#include "saiga/core/util/Thread/SpinLock.h"
#include "saiga/core/util/Thread/omp.h"

#include "MarchingCubes.h"

namespace Saiga
{
// A block sparse truncated signed distance field.
// Generated by integrating (fusing) aligned depth maps.
// Each block consists of VOXEL_BLOCK_SIZE^3 voxels.
// A typical value for VOXEL_BLOCK_SIZE is 8.
//
// The size in meters is given in the constructor.
//
// The voxel blocks are stored sparse using a hashmap. For each hashbucket,
// we store a linked-list with all blocks inside this bucket.
template <int _VOXEL_BLOCK_SIZE>
struct SAIGA_TEMPLATE SparseTSDF
{
    static constexpr int VOXEL_BLOCK_SIZE = _VOXEL_BLOCK_SIZE;
    using VoxelBlockIndex                 = ivec3;

    // Each TSDF voxel consists of the (signed) distance to the surface and a confidence weight.
    // If desired, you can add a RGB member to estimate the color during integration.
    struct Voxel
    {
        float distance = std::numeric_limits<float>::infinity();
        float weight   = 0;
    };


    // A voxel block is a 3 dimensional array of voxels.
    // Given a VOXEL_BLOCK_SIZE of 8 a voxel blocks consists of 8*8*8=512 voxels.
    //
    // Due to the sparse storage, each voxel block has to known it's own index.
    // The next_index points to the next voxel block in the same hash bucket.
    struct VoxelBlock
    {
        Voxel data[VOXEL_BLOCK_SIZE][VOXEL_BLOCK_SIZE][VOXEL_BLOCK_SIZE];
        VoxelBlockIndex index = VoxelBlockIndex(-973454, -973454, -973454);
        int next_index        = -1;
    };


    SparseTSDF(float voxel_size, int reserve_blocks, int hash_size)
        : voxel_size(voxel_size),
          voxel_size_inv(1.0 / voxel_size),
          hash_size(hash_size),
          blocks(reserve_blocks),
          first_hashed_block(hash_size, -1),
          hash_locks(hash_size)

    {
        block_size_inv = 1.0 / (voxel_size * VOXEL_BLOCK_SIZE);

        std::cout << "SparseTSDF created. Allocated Memory: " << Memory() / (1000 * 1000) << " MB." << std::endl;
    }

    void Print(std::ostream& strm)
    {
        size_t mem_blocks = blocks.capacity() * sizeof(VoxelBlock);
        size_t mem_hash   = first_hashed_block.capacity() * sizeof(int);

        strm << "[SparseTSDF]" << std::endl;
        strm << "  VoxelSize    " << voxel_size << std::endl;
        strm << "  hash_size    " << hash_size << std::endl;
        strm << "  Blocks       " << current_blocks << "/" << blocks.size() << std::endl;
        strm << "  Mem Blocks   " << mem_blocks / (1000.0 * 1000) << " MB" << std::endl;
        strm << "  Mem Hash     " << mem_hash / (1000.0 * 1000) << " MB" << std::endl;
    }

    size_t Memory()
    {
        size_t mem_blocks = blocks.capacity() * sizeof(VoxelBlock);
        size_t mem_hash   = first_hashed_block.capacity() * sizeof(int);
        return mem_blocks + mem_hash + sizeof(*this);
    }

    // Returns the voxel block or 0 if it doesn't exist.
    VoxelBlock* GetBlock(const VoxelBlockIndex& i) { return GetBlock(i, H(i)); }


    // Insert a new block into the TSDF and returns a pointer to it.
    // If the block already exists, nothing is inserted.
    VoxelBlock* InsertBlock(const VoxelBlockIndex& i)
    {
        int h      = H(i);
        auto block = GetBlock(i, h);

        if (block)
        {
            // block already exists
            return block;
        }

        // Create block and insert as the first element.
        int new_index = current_blocks.fetch_add(1);

        if (new_index >= blocks.size())
        {
            blocks.resize(blocks.size() * 2);
        }

        int hash                 = H(i);
        auto* new_block          = &blocks[new_index];
        new_block->index         = i;
        new_block->next_index    = first_hashed_block[hash];
        first_hashed_block[hash] = new_index;
        return new_block;
    }

    VoxelBlock* InsertBlockLock(const VoxelBlockIndex& i)
    {
        int h = H(i);

        std::unique_lock lock(hash_locks[h]);

        auto block = GetBlock(i, h);

        if (block)
        {
            // block already exists
            return block;
        }

        // Create block and insert as the first element.
        int new_index = current_blocks.fetch_add(1);

        if (new_index >= blocks.size())
        {
            SAIGA_EXIT_ERROR("Resizing not allowed during parallel insertion!");
        }

        int hash                 = H(i);
        auto* new_block          = &blocks[new_index];
        new_block->index         = i;
        new_block->next_index    = first_hashed_block[hash];
        first_hashed_block[hash] = new_index;
        return new_block;
    }

    VoxelBlockIndex GetBlockIndex(const vec3& position)
    {
        vec3 normalized_position = (position - make_vec3(0.5f * voxel_size)) * block_size_inv;
        return normalized_position.array().floor().cast<int>();
    }

    vec3 BlockCenter(const VoxelBlockIndex& i)
    {
        int half_size = VOXEL_BLOCK_SIZE / 2;
        return GlobalPosition(i, half_size, half_size, half_size);
    }

    // The bottom right corner of this voxelblock
    vec3 GlobalBlockOffset(const VoxelBlockIndex& i) { return i.cast<float>() * voxel_size * VOXEL_BLOCK_SIZE; }

    vec3 GlobalPosition(const VoxelBlockIndex& i, int z, int y, int x)
    {
        return vec3(x, y, z) * voxel_size + GlobalBlockOffset(i);
    }


    using Triangle = std::array<vec3, 3>;

    // Triangle surface extraction on the sparse TSDF.
    std::vector<std::vector<Triangle>> ExtractSurface(double iso, int threads = OMP::getMaxThreads())
    {
        SyncedConsoleProgressBar loading_bar(std::cout, "Extracing surface", current_blocks);

        //        std::vector<std::vector<std::array<vec3, 3>>> triangle_soup_thread(threads);

        // Each block generates a list of triangles
        std::vector<std::vector<Triangle>> triangle_soup_per_block(current_blocks);

#pragma omp parallel for num_threads(threads)
        for (int b = 0; b < current_blocks; ++b)
        {
            auto& triangle_soup = triangle_soup_per_block[b];
            auto& block         = blocks[b];
            // Compute positions and values of (n+1) x (n+1) x (n+1) block.
            // The (+1) data point is taken from neighbouring blocks to close the holes.
            std::pair<vec3, float> local_data[VOXEL_BLOCK_SIZE + 1][VOXEL_BLOCK_SIZE + 1][VOXEL_BLOCK_SIZE + 1];

            // Fill from own block
            for (int i = 0; i < VOXEL_BLOCK_SIZE + 1; ++i)
            {
                for (int j = 0; j < VOXEL_BLOCK_SIZE + 1; ++j)
                {
                    for (int k = 0; k < VOXEL_BLOCK_SIZE + 1; ++k)
                    {
                        int li = i % VOXEL_BLOCK_SIZE;
                        int lj = j % VOXEL_BLOCK_SIZE;
                        int lk = k % VOXEL_BLOCK_SIZE;

                        int bi = i / VOXEL_BLOCK_SIZE;
                        int bj = j / VOXEL_BLOCK_SIZE;
                        int bk = k / VOXEL_BLOCK_SIZE;

                        VoxelBlockIndex read_block_id = block.index + ivec3(bk, bj, bi);

                        auto* read_block = GetBlock(read_block_id);


                        vec3 p = GlobalPosition(block.index, i, j, k);

                        if (read_block)
                        {
                            float dis           = read_block->data[li][lj][lk].distance;
                            local_data[i][j][k] = {p, dis};
                        }
                        else
                        {
                            local_data[i][j][k] = {p, std::numeric_limits<float>::infinity()};
                        }
                    }
                }
            }


            // create triangles
            for (int i = 0; i < VOXEL_BLOCK_SIZE; ++i)
            {
                for (int j = 0; j < VOXEL_BLOCK_SIZE; ++j)
                {
                    for (int k = 0; k < VOXEL_BLOCK_SIZE; ++k)
                    {
                        std::array<std::pair<vec3, float>, 8> cell;

                        cell[0] = local_data[i][j][k];
                        cell[1] = local_data[i][j][k + 1];
                        cell[2] = local_data[i + 1][j][k + 1];
                        cell[3] = local_data[i + 1][j][k];
                        cell[4] = local_data[i][j + 1][k];
                        cell[5] = local_data[i][j + 1][k + 1];
                        cell[6] = local_data[i + 1][j + 1][k + 1];
                        cell[7] = local_data[i + 1][j + 1][k];

                        bool finite = true;

                        for (auto i = 0; i < 8; ++i)
                        {
                            finite &= std::isfinite(cell[i].second);
                        }

                        if (!finite)
                        {
                            continue;
                        }

                        auto [triangles, count] = MarchingCubes(cell, iso);


                        for (int n = 0; n < count; ++n)
                        {
                            auto tri = triangles[n];
                            triangle_soup.push_back(tri);
                        }
                    }
                }
            }
            loading_bar.addProgress(1);
        }


        return triangle_soup_per_block;
    }


   public:
    float voxel_size;
    float voxel_size_inv;

    float block_size_inv;


    unsigned int hash_size;
    std::atomic_int current_blocks = 0;
    std::vector<VoxelBlock> blocks;
    std::vector<int> first_hashed_block;
    std::vector<SpinLock> hash_locks;

    int H(const VoxelBlockIndex& i)
    {
        unsigned int u = i.x() + i.y() * 1000 + i.z() * 1000 * 1000;
        int result     = u % hash_size;
        SAIGA_ASSERT(result >= 0 && result < hash_size);
        return result;
    }

    // Returns the voxel block or 0 if it doesn't exist.
    VoxelBlock* GetBlock(const VoxelBlockIndex& i, int hash)
    {
        int block_id = first_hashed_block[hash];

        while (block_id != -1)
        {
            auto* block = &blocks[block_id];
            if (block->index == i)
            {
                return block;
            }

            block_id = block->next_index;
        }
        return nullptr;
    }
};



}  // namespace Saiga
